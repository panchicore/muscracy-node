module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateMediaItem {
  count: Int!
}

type AggregateRadio {
  count: Int!
}

type AggregateRadioUser {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type MediaItem {
  id: ID!
  externalId: String!
  title: String!
  source: String!
  sentBy: User!
  sentAt: DateTime!
  radio: Radio!
  status: MediaItemStatus!
  thumbnailUrl: String
  channelTitle: String
  publishedAt: DateTime
}

type MediaItemConnection {
  pageInfo: PageInfo!
  edges: [MediaItemEdge]!
  aggregate: AggregateMediaItem!
}

input MediaItemCreateInput {
  id: ID
  externalId: String!
  title: String!
  source: String!
  sentBy: UserCreateOneInput!
  radio: RadioCreateOneWithoutMediaItemsInput!
  status: MediaItemStatus
  thumbnailUrl: String
  channelTitle: String
  publishedAt: DateTime
}

input MediaItemCreateManyWithoutRadioInput {
  create: [MediaItemCreateWithoutRadioInput!]
  connect: [MediaItemWhereUniqueInput!]
}

input MediaItemCreateWithoutRadioInput {
  id: ID
  externalId: String!
  title: String!
  source: String!
  sentBy: UserCreateOneInput!
  status: MediaItemStatus
  thumbnailUrl: String
  channelTitle: String
  publishedAt: DateTime
}

type MediaItemEdge {
  node: MediaItem!
  cursor: String!
}

enum MediaItemOrderByInput {
  id_ASC
  id_DESC
  externalId_ASC
  externalId_DESC
  title_ASC
  title_DESC
  source_ASC
  source_DESC
  sentAt_ASC
  sentAt_DESC
  status_ASC
  status_DESC
  thumbnailUrl_ASC
  thumbnailUrl_DESC
  channelTitle_ASC
  channelTitle_DESC
  publishedAt_ASC
  publishedAt_DESC
}

type MediaItemPreviousValues {
  id: ID!
  externalId: String!
  title: String!
  source: String!
  sentAt: DateTime!
  status: MediaItemStatus!
  thumbnailUrl: String
  channelTitle: String
  publishedAt: DateTime
}

input MediaItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  externalId: String
  externalId_not: String
  externalId_in: [String!]
  externalId_not_in: [String!]
  externalId_lt: String
  externalId_lte: String
  externalId_gt: String
  externalId_gte: String
  externalId_contains: String
  externalId_not_contains: String
  externalId_starts_with: String
  externalId_not_starts_with: String
  externalId_ends_with: String
  externalId_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  sentAt: DateTime
  sentAt_not: DateTime
  sentAt_in: [DateTime!]
  sentAt_not_in: [DateTime!]
  sentAt_lt: DateTime
  sentAt_lte: DateTime
  sentAt_gt: DateTime
  sentAt_gte: DateTime
  status: MediaItemStatus
  status_not: MediaItemStatus
  status_in: [MediaItemStatus!]
  status_not_in: [MediaItemStatus!]
  thumbnailUrl: String
  thumbnailUrl_not: String
  thumbnailUrl_in: [String!]
  thumbnailUrl_not_in: [String!]
  thumbnailUrl_lt: String
  thumbnailUrl_lte: String
  thumbnailUrl_gt: String
  thumbnailUrl_gte: String
  thumbnailUrl_contains: String
  thumbnailUrl_not_contains: String
  thumbnailUrl_starts_with: String
  thumbnailUrl_not_starts_with: String
  thumbnailUrl_ends_with: String
  thumbnailUrl_not_ends_with: String
  channelTitle: String
  channelTitle_not: String
  channelTitle_in: [String!]
  channelTitle_not_in: [String!]
  channelTitle_lt: String
  channelTitle_lte: String
  channelTitle_gt: String
  channelTitle_gte: String
  channelTitle_contains: String
  channelTitle_not_contains: String
  channelTitle_starts_with: String
  channelTitle_not_starts_with: String
  channelTitle_ends_with: String
  channelTitle_not_ends_with: String
  publishedAt: DateTime
  publishedAt_not: DateTime
  publishedAt_in: [DateTime!]
  publishedAt_not_in: [DateTime!]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  AND: [MediaItemScalarWhereInput!]
  OR: [MediaItemScalarWhereInput!]
  NOT: [MediaItemScalarWhereInput!]
}

enum MediaItemStatus {
  REQUESTED
  REJECTED
  QUEUED
  NOW_PLAYING
  PLAYED
}

type MediaItemSubscriptionPayload {
  mutation: MutationType!
  node: MediaItem
  updatedFields: [String!]
  previousValues: MediaItemPreviousValues
}

input MediaItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MediaItemWhereInput
  AND: [MediaItemSubscriptionWhereInput!]
  OR: [MediaItemSubscriptionWhereInput!]
  NOT: [MediaItemSubscriptionWhereInput!]
}

input MediaItemUpdateInput {
  externalId: String
  title: String
  source: String
  sentBy: UserUpdateOneRequiredInput
  radio: RadioUpdateOneRequiredWithoutMediaItemsInput
  status: MediaItemStatus
  thumbnailUrl: String
  channelTitle: String
  publishedAt: DateTime
}

input MediaItemUpdateManyDataInput {
  externalId: String
  title: String
  source: String
  status: MediaItemStatus
  thumbnailUrl: String
  channelTitle: String
  publishedAt: DateTime
}

input MediaItemUpdateManyMutationInput {
  externalId: String
  title: String
  source: String
  status: MediaItemStatus
  thumbnailUrl: String
  channelTitle: String
  publishedAt: DateTime
}

input MediaItemUpdateManyWithoutRadioInput {
  create: [MediaItemCreateWithoutRadioInput!]
  delete: [MediaItemWhereUniqueInput!]
  connect: [MediaItemWhereUniqueInput!]
  set: [MediaItemWhereUniqueInput!]
  disconnect: [MediaItemWhereUniqueInput!]
  update: [MediaItemUpdateWithWhereUniqueWithoutRadioInput!]
  upsert: [MediaItemUpsertWithWhereUniqueWithoutRadioInput!]
  deleteMany: [MediaItemScalarWhereInput!]
  updateMany: [MediaItemUpdateManyWithWhereNestedInput!]
}

input MediaItemUpdateManyWithWhereNestedInput {
  where: MediaItemScalarWhereInput!
  data: MediaItemUpdateManyDataInput!
}

input MediaItemUpdateWithoutRadioDataInput {
  externalId: String
  title: String
  source: String
  sentBy: UserUpdateOneRequiredInput
  status: MediaItemStatus
  thumbnailUrl: String
  channelTitle: String
  publishedAt: DateTime
}

input MediaItemUpdateWithWhereUniqueWithoutRadioInput {
  where: MediaItemWhereUniqueInput!
  data: MediaItemUpdateWithoutRadioDataInput!
}

input MediaItemUpsertWithWhereUniqueWithoutRadioInput {
  where: MediaItemWhereUniqueInput!
  update: MediaItemUpdateWithoutRadioDataInput!
  create: MediaItemCreateWithoutRadioInput!
}

input MediaItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  externalId: String
  externalId_not: String
  externalId_in: [String!]
  externalId_not_in: [String!]
  externalId_lt: String
  externalId_lte: String
  externalId_gt: String
  externalId_gte: String
  externalId_contains: String
  externalId_not_contains: String
  externalId_starts_with: String
  externalId_not_starts_with: String
  externalId_ends_with: String
  externalId_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  sentBy: UserWhereInput
  sentAt: DateTime
  sentAt_not: DateTime
  sentAt_in: [DateTime!]
  sentAt_not_in: [DateTime!]
  sentAt_lt: DateTime
  sentAt_lte: DateTime
  sentAt_gt: DateTime
  sentAt_gte: DateTime
  radio: RadioWhereInput
  status: MediaItemStatus
  status_not: MediaItemStatus
  status_in: [MediaItemStatus!]
  status_not_in: [MediaItemStatus!]
  thumbnailUrl: String
  thumbnailUrl_not: String
  thumbnailUrl_in: [String!]
  thumbnailUrl_not_in: [String!]
  thumbnailUrl_lt: String
  thumbnailUrl_lte: String
  thumbnailUrl_gt: String
  thumbnailUrl_gte: String
  thumbnailUrl_contains: String
  thumbnailUrl_not_contains: String
  thumbnailUrl_starts_with: String
  thumbnailUrl_not_starts_with: String
  thumbnailUrl_ends_with: String
  thumbnailUrl_not_ends_with: String
  channelTitle: String
  channelTitle_not: String
  channelTitle_in: [String!]
  channelTitle_not_in: [String!]
  channelTitle_lt: String
  channelTitle_lte: String
  channelTitle_gt: String
  channelTitle_gte: String
  channelTitle_contains: String
  channelTitle_not_contains: String
  channelTitle_starts_with: String
  channelTitle_not_starts_with: String
  channelTitle_ends_with: String
  channelTitle_not_ends_with: String
  publishedAt: DateTime
  publishedAt_not: DateTime
  publishedAt_in: [DateTime!]
  publishedAt_not_in: [DateTime!]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  AND: [MediaItemWhereInput!]
  OR: [MediaItemWhereInput!]
  NOT: [MediaItemWhereInput!]
}

input MediaItemWhereUniqueInput {
  id: ID
}

type Mutation {
  createMediaItem(data: MediaItemCreateInput!): MediaItem!
  updateMediaItem(data: MediaItemUpdateInput!, where: MediaItemWhereUniqueInput!): MediaItem
  updateManyMediaItems(data: MediaItemUpdateManyMutationInput!, where: MediaItemWhereInput): BatchPayload!
  upsertMediaItem(where: MediaItemWhereUniqueInput!, create: MediaItemCreateInput!, update: MediaItemUpdateInput!): MediaItem!
  deleteMediaItem(where: MediaItemWhereUniqueInput!): MediaItem
  deleteManyMediaItems(where: MediaItemWhereInput): BatchPayload!
  createRadio(data: RadioCreateInput!): Radio!
  updateRadio(data: RadioUpdateInput!, where: RadioWhereUniqueInput!): Radio
  updateManyRadios(data: RadioUpdateManyMutationInput!, where: RadioWhereInput): BatchPayload!
  upsertRadio(where: RadioWhereUniqueInput!, create: RadioCreateInput!, update: RadioUpdateInput!): Radio!
  deleteRadio(where: RadioWhereUniqueInput!): Radio
  deleteManyRadios(where: RadioWhereInput): BatchPayload!
  createRadioUser(data: RadioUserCreateInput!): RadioUser!
  updateRadioUser(data: RadioUserUpdateInput!, where: RadioUserWhereUniqueInput!): RadioUser
  upsertRadioUser(where: RadioUserWhereUniqueInput!, create: RadioUserCreateInput!, update: RadioUserUpdateInput!): RadioUser!
  deleteRadioUser(where: RadioUserWhereUniqueInput!): RadioUser
  deleteManyRadioUsers(where: RadioUserWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  mediaItem(where: MediaItemWhereUniqueInput!): MediaItem
  mediaItems(where: MediaItemWhereInput, orderBy: MediaItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MediaItem]!
  mediaItemsConnection(where: MediaItemWhereInput, orderBy: MediaItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MediaItemConnection!
  radio(where: RadioWhereUniqueInput!): Radio
  radios(where: RadioWhereInput, orderBy: RadioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Radio]!
  radiosConnection(where: RadioWhereInput, orderBy: RadioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RadioConnection!
  radioUser(where: RadioUserWhereUniqueInput!): RadioUser
  radioUsers(where: RadioUserWhereInput, orderBy: RadioUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RadioUser]!
  radioUsersConnection(where: RadioUserWhereInput, orderBy: RadioUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RadioUserConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Radio {
  id: ID!
  name: String!
  hash: String!
  createdBy: User!
  people(where: RadioUserWhereInput, orderBy: RadioUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RadioUser!]
  mediaItems(where: MediaItemWhereInput, orderBy: MediaItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MediaItem!]
}

type RadioConnection {
  pageInfo: PageInfo!
  edges: [RadioEdge]!
  aggregate: AggregateRadio!
}

input RadioCreateInput {
  id: ID
  name: String!
  hash: String!
  createdBy: UserCreateOneInput!
  people: RadioUserCreateManyWithoutRadioInput
  mediaItems: MediaItemCreateManyWithoutRadioInput
}

input RadioCreateOneWithoutMediaItemsInput {
  create: RadioCreateWithoutMediaItemsInput
  connect: RadioWhereUniqueInput
}

input RadioCreateOneWithoutPeopleInput {
  create: RadioCreateWithoutPeopleInput
  connect: RadioWhereUniqueInput
}

input RadioCreateWithoutMediaItemsInput {
  id: ID
  name: String!
  hash: String!
  createdBy: UserCreateOneInput!
  people: RadioUserCreateManyWithoutRadioInput
}

input RadioCreateWithoutPeopleInput {
  id: ID
  name: String!
  hash: String!
  createdBy: UserCreateOneInput!
  mediaItems: MediaItemCreateManyWithoutRadioInput
}

type RadioEdge {
  node: Radio!
  cursor: String!
}

enum RadioOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  hash_ASC
  hash_DESC
}

type RadioPreviousValues {
  id: ID!
  name: String!
  hash: String!
}

type RadioSubscriptionPayload {
  mutation: MutationType!
  node: Radio
  updatedFields: [String!]
  previousValues: RadioPreviousValues
}

input RadioSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RadioWhereInput
  AND: [RadioSubscriptionWhereInput!]
  OR: [RadioSubscriptionWhereInput!]
  NOT: [RadioSubscriptionWhereInput!]
}

input RadioUpdateInput {
  name: String
  hash: String
  createdBy: UserUpdateOneRequiredInput
  people: RadioUserUpdateManyWithoutRadioInput
  mediaItems: MediaItemUpdateManyWithoutRadioInput
}

input RadioUpdateManyMutationInput {
  name: String
  hash: String
}

input RadioUpdateOneRequiredWithoutMediaItemsInput {
  create: RadioCreateWithoutMediaItemsInput
  update: RadioUpdateWithoutMediaItemsDataInput
  upsert: RadioUpsertWithoutMediaItemsInput
  connect: RadioWhereUniqueInput
}

input RadioUpdateOneRequiredWithoutPeopleInput {
  create: RadioCreateWithoutPeopleInput
  update: RadioUpdateWithoutPeopleDataInput
  upsert: RadioUpsertWithoutPeopleInput
  connect: RadioWhereUniqueInput
}

input RadioUpdateWithoutMediaItemsDataInput {
  name: String
  hash: String
  createdBy: UserUpdateOneRequiredInput
  people: RadioUserUpdateManyWithoutRadioInput
}

input RadioUpdateWithoutPeopleDataInput {
  name: String
  hash: String
  createdBy: UserUpdateOneRequiredInput
  mediaItems: MediaItemUpdateManyWithoutRadioInput
}

input RadioUpsertWithoutMediaItemsInput {
  update: RadioUpdateWithoutMediaItemsDataInput!
  create: RadioCreateWithoutMediaItemsInput!
}

input RadioUpsertWithoutPeopleInput {
  update: RadioUpdateWithoutPeopleDataInput!
  create: RadioCreateWithoutPeopleInput!
}

type RadioUser {
  id: ID!
  connectedAt: DateTime!
  user: User!
  radio: Radio!
}

type RadioUserConnection {
  pageInfo: PageInfo!
  edges: [RadioUserEdge]!
  aggregate: AggregateRadioUser!
}

input RadioUserCreateInput {
  id: ID
  user: UserCreateOneInput!
  radio: RadioCreateOneWithoutPeopleInput!
}

input RadioUserCreateManyWithoutRadioInput {
  create: [RadioUserCreateWithoutRadioInput!]
  connect: [RadioUserWhereUniqueInput!]
}

input RadioUserCreateWithoutRadioInput {
  id: ID
  user: UserCreateOneInput!
}

type RadioUserEdge {
  node: RadioUser!
  cursor: String!
}

enum RadioUserOrderByInput {
  id_ASC
  id_DESC
  connectedAt_ASC
  connectedAt_DESC
}

type RadioUserPreviousValues {
  id: ID!
  connectedAt: DateTime!
}

input RadioUserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  connectedAt: DateTime
  connectedAt_not: DateTime
  connectedAt_in: [DateTime!]
  connectedAt_not_in: [DateTime!]
  connectedAt_lt: DateTime
  connectedAt_lte: DateTime
  connectedAt_gt: DateTime
  connectedAt_gte: DateTime
  AND: [RadioUserScalarWhereInput!]
  OR: [RadioUserScalarWhereInput!]
  NOT: [RadioUserScalarWhereInput!]
}

type RadioUserSubscriptionPayload {
  mutation: MutationType!
  node: RadioUser
  updatedFields: [String!]
  previousValues: RadioUserPreviousValues
}

input RadioUserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RadioUserWhereInput
  AND: [RadioUserSubscriptionWhereInput!]
  OR: [RadioUserSubscriptionWhereInput!]
  NOT: [RadioUserSubscriptionWhereInput!]
}

input RadioUserUpdateInput {
  user: UserUpdateOneRequiredInput
  radio: RadioUpdateOneRequiredWithoutPeopleInput
}

input RadioUserUpdateManyWithoutRadioInput {
  create: [RadioUserCreateWithoutRadioInput!]
  delete: [RadioUserWhereUniqueInput!]
  connect: [RadioUserWhereUniqueInput!]
  set: [RadioUserWhereUniqueInput!]
  disconnect: [RadioUserWhereUniqueInput!]
  update: [RadioUserUpdateWithWhereUniqueWithoutRadioInput!]
  upsert: [RadioUserUpsertWithWhereUniqueWithoutRadioInput!]
  deleteMany: [RadioUserScalarWhereInput!]
}

input RadioUserUpdateWithoutRadioDataInput {
  user: UserUpdateOneRequiredInput
}

input RadioUserUpdateWithWhereUniqueWithoutRadioInput {
  where: RadioUserWhereUniqueInput!
  data: RadioUserUpdateWithoutRadioDataInput!
}

input RadioUserUpsertWithWhereUniqueWithoutRadioInput {
  where: RadioUserWhereUniqueInput!
  update: RadioUserUpdateWithoutRadioDataInput!
  create: RadioUserCreateWithoutRadioInput!
}

input RadioUserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  connectedAt: DateTime
  connectedAt_not: DateTime
  connectedAt_in: [DateTime!]
  connectedAt_not_in: [DateTime!]
  connectedAt_lt: DateTime
  connectedAt_lte: DateTime
  connectedAt_gt: DateTime
  connectedAt_gte: DateTime
  user: UserWhereInput
  radio: RadioWhereInput
  AND: [RadioUserWhereInput!]
  OR: [RadioUserWhereInput!]
  NOT: [RadioUserWhereInput!]
}

input RadioUserWhereUniqueInput {
  id: ID
}

input RadioWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  hash: String
  hash_not: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_lt: String
  hash_lte: String
  hash_gt: String
  hash_gte: String
  hash_contains: String
  hash_not_contains: String
  hash_starts_with: String
  hash_not_starts_with: String
  hash_ends_with: String
  hash_not_ends_with: String
  createdBy: UserWhereInput
  people_every: RadioUserWhereInput
  people_some: RadioUserWhereInput
  people_none: RadioUserWhereInput
  mediaItems_every: MediaItemWhereInput
  mediaItems_some: MediaItemWhereInput
  mediaItems_none: MediaItemWhereInput
  AND: [RadioWhereInput!]
  OR: [RadioWhereInput!]
  NOT: [RadioWhereInput!]
}

input RadioWhereUniqueInput {
  id: ID
  hash: String
}

type Subscription {
  mediaItem(where: MediaItemSubscriptionWhereInput): MediaItemSubscriptionPayload
  radio(where: RadioSubscriptionWhereInput): RadioSubscriptionPayload
  radioUser(where: RadioUserSubscriptionWhereInput): RadioUserSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  email: String!
  password: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  password: String!
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  name: String
  email: String
  password: String
}

input UserUpdateInput {
  name: String
  email: String
  password: String
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  password: String
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    